# SQL Server columnstoreIn-Memory Columnstore gives great performance to queries that scan large sets of rows (millions of rows typically), and also provides huge savings in storage space.  Typical compression rates can be 90%.  They are best used for analytics queries, and are default for many data warehouse schemas.  When paired with Nonclustered indexes, they can support OLTP queries efficiently as well.The performance gains come from:* Data is physically organized by column rather than traditional pages which hold a number of complete rows.* Data in s single row compresses very will since it is typically in the same data domain.* Queries only need to read the data for those columns that the queries touch into memory.  No data from other columns needs to be touched.* Batch operations dramatically speed up aggregations on groups of rows at a time. ##Samples Included* **Nonclustered Columnstore** This demo walks through adding a nonclustered columnstore to an OLTP table to enable fast analytics on an operational datastore.* **In-Memory Columnstore** This demo walks through creating an in-memory columnstore index on an In-Memory OLTP table to provide extremely fast analytics on an extremely fast in-memory OLTP table.